import os
import sys
import logging
import random
import asyncio
import pytz
import requests
import string
from Script import script
from datetime import datetime, timedelta
from pyrogram import Client, filters, enums
from pyrogram.errors import ChatAdminRequired, FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from database.ia_filterdb import Media, get_file_details, unpack_new_file_id, get_bad_files, get_search_results
from database.users_chats_db import db
from database.safari_reffer import sdb
from info import *
from utils import get_size, is_subscribed, temp, get_shortlink, get_seconds
import re
import json
import base64
logger = logging.getLogger(__name__)

TIMEZONE = "Asia/Kolkata"

@Client.on_message(filters.command("start") & filters.incoming)
async def start(client, message):
    try: 
        user_id = message.from_user.id
        if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            buttons = [[
                        InlineKeyboardButton('â˜† á´€á´…á´… á´á´‡ á´›á´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ â˜†', url=f'http://t.me/{temp.U_NAME}?startgroup=true')
                      ]]
            reply_markup = InlineKeyboardMarkup(buttons)
            await message.reply_text(
                text="á´á´‹ Éª á´„á´€É´ Êœá´‡ÊŸá´˜ Êá´á´œ á´Šá´œsá´› sá´›á´€Ê€á´› á´˜á´", 
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            await asyncio.sleep(2) # ğŸ˜¢ https://github.com/EvamariaTG/EvaMaria/blob/master/plugins/p_ttishow.py#L17 ğŸ˜¬ wait a bit, before checking.
            if not await db.get_chat(message.chat.id):
                total=await client.get_chat_members_count(message.chat.id)
                await client.send_message(LOG_CHANNEL, script.LOG_TEXT_G.format(temp.B_NAME, message.chat.title, message.chat.id, total, "Unknown"))       
                await db.add_chat(message.chat.id, message.chat.title, message.from_user.id)
            return 
        if not await db.is_user_exist(message.from_user.id):
            await db.add_user(message.from_user.id, message.from_user.first_name)
            await client.send_message(LOG_CHANNEL, script.LOG_TEXT_P.format(message.from_user.id, message.from_user.mention, temp.B_NAME))
        if len(message.command) != 2:
            buttons = [[
                        InlineKeyboardButton('â˜† á´€á´…á´… á´á´‡ á´›á´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ â˜†', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')
                    ],[
                        InlineKeyboardButton('ğŸ“¢ á´œá´˜á´…á´€á´›á´‡êœ±', callback_data='channels'), 
                        InlineKeyboardButton('âœ¨ Ò“á´‡á´€á´›á´œÊ€á´‡s', callback_data='features')
                    ],[
                        InlineKeyboardButton('â“Há´‡ÊŸá´˜', callback_data='help'),
                        InlineKeyboardButton('â„¹ á´€Ê™á´á´œá´›', callback_data='about')
                    ]]
            if await db.get_setting("IS_VERIFY", default=IS_VERIFY):
                buttons.append(
                        [InlineKeyboardButton('ğŸ Ò“Ê€á´‡á´‡ á´˜Ê€á´‡á´Éªá´œá´', callback_data="pm_reff"),
                        InlineKeyboardButton('ğŸ’ Ê™á´œÊ á´˜Ê€á´‡á´Éªá´œá´ âœ¨', callback_data="premium")])
            reply_markup = InlineKeyboardMarkup(buttons)
            await message.reply_photo(
                photo=random.choice(PICS),
                caption=script.START_TXT.format(message.from_user.mention, temp.U_NAME, temp.B_NAME),
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            return
        if len(message.command) == 2 and message.command[1] in ["subscribe", "error", "okay", "help"]:
            buttons = [[
                        InlineKeyboardButton('â˜† á´€á´…á´… á´á´‡ á´›á´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ â˜†', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')
                    ],[
                        InlineKeyboardButton('ğŸ“¢ á´œá´˜á´…á´€á´›á´‡êœ±', callback_data='channels'), 
                        InlineKeyboardButton('âœ¨ Ò“á´‡á´€á´›á´œÊ€á´‡s', callback_data='features')
                    ],[
                        InlineKeyboardButton('â“Há´‡ÊŸá´˜', callback_data='help'),
                        InlineKeyboardButton('â„¹ á´€Ê™á´á´œá´›', callback_data='about')
                    ]]
            if await db.get_setting("IS_VERIFY", default=IS_VERIFY):
                buttons.append(
                        [InlineKeyboardButton('ğŸ Ò“Ê€á´‡á´‡ á´˜Ê€á´‡á´Éªá´œá´', callback_data="pm_reff"),
                        InlineKeyboardButton('ğŸ’ Ê™á´œÊ á´˜Ê€á´‡á´Éªá´œá´ âœ¨', callback_data="premium")])
            reply_markup = InlineKeyboardMarkup(buttons)
            await message.reply_photo(
                photo=random.choice(PICS),
                caption=script.START_TXT.format(message.from_user.mention, temp.U_NAME, temp.B_NAME),
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            return
        if len(message.command) == 2 and message.command[1] in ["safaridev"]:
            buttons = [[
                        InlineKeyboardButton('ğŸ“² êœ±á´‡É´á´… á´˜á´€Êá´á´‡É´á´› êœ±á´„Ê€á´‡á´‡É´êœ±Êœá´á´›', url=f"https://t.me/{OWNER_USER_NAME}")
                      ],[
                        InlineKeyboardButton('âŒ á´„ÊŸá´êœ±á´‡ âŒ', callback_data='close_data')
                      ]]
            reply_markup = InlineKeyboardMarkup(buttons)
            await message.reply_photo(
                photo=(PREMIUM_PIC),
                caption=script.PREMIUM_CMD,
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            return  
        if message.command[1].startswith("reff_"):
            try:
                user_id = int(message.command[1].split("_")[1])
            except ValueError:
                await message.reply_text("Invalid refer!")
                return
            if user_id == message.from_user.id:
                await message.reply_text("Há´‡Ê Dá´œá´…á´‡, Yá´á´œ Cá´€É´'á´› Rá´‡Ò“á´‡Ê€ Yá´á´œÊ€sá´‡ÊŸÒ“ ğŸ¤£!\n\nsÊœá´€Ê€á´‡ ÊŸÉªÉ´á´‹ Êá´á´œÊ€ Ò“Ê€Éªá´‡É´á´… á´€É´á´… É¢á´‡á´› 5 Ê€á´‡Ò“á´‡Ê€Ê€á´€ÊŸ á´˜á´ÉªÉ´á´› ÉªÒ“ Êá´á´œ á´€Ê€á´‡ á´„á´ÊŸÊŸá´‡á´„á´›ÉªÉ´É¢ 50 Ê€á´‡Ò“á´‡Ê€Ê€á´€ÊŸ á´˜á´ÉªÉ´á´›s á´›Êœá´‡É´ Êá´á´œ á´„á´€É´ É¢á´‡á´› 1 á´á´É´á´›Êœ Ò“Ê€á´‡á´‡ á´˜Ê€á´‡á´Éªá´œá´ á´á´‡á´Ê™á´‡Ê€sÊœÉªá´˜.")
                return
            if sdb.is_user_in_list(message.from_user.id):
                await message.reply_text("Yá´á´œ Êœá´€á´ á´‡ Ê™á´‡á´‡É´ á´€ÊŸÊ€á´‡á´€á´…Ê ÉªÉ´á´ Éªá´›á´‡á´… â—")
                return
            try:
                uss = await client.get_users(user_id)
            except Exception:
                return 	    
            sdb.add_user(message.from_user.id)
            fromuse = sdb.get_refer_points(user_id) + 10
            sdb.add_refer_points(user_id, fromuse)
            await message.reply_text(f"You have been successfully invited by {uss.mention}!")
            await client.send_message(user_id, f"ğ—–ğ—¼ğ—»ğ—´ğ—¿ğ—®ğ˜ğ˜‚ğ—¹ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ˜€! ğ—¬ğ—¼ğ˜‚ ğ˜„ğ—¼ğ—» ğŸ­ğŸ¬ ğ—¥ğ—²ğ—³ğ—²ğ—¿ğ—¿ğ—®ğ—¹ ğ—½ğ—¼ğ—¶ğ—»ğ˜ ğ—¯ğ—²ğ—°ğ—®ğ˜‚ğ˜€ğ—² ğ—¬ğ—¼ğ˜‚ ğ—µğ—®ğ˜ƒğ—² ğ—¯ğ—²ğ—²ğ—» ğ—¦ğ˜‚ğ—°ğ—°ğ—²ğ˜€ğ˜€ğ—³ğ˜‚ğ—¹ğ—¹ğ˜† ğ—œğ—»ğ˜ƒğ—¶ğ˜ğ—²ğ—± â˜{message.from_user.mention}!") 
            if fromuse == REFFER_POINT:
                await db.give_referal(user_id)
                sdb.add_refer_points(user_id, 0) 
                await client.send_message(chat_id=user_id,
                    text=f"<b>Há´‡Ê {uss.mention}\n\nYá´á´œ É¢á´á´› 1 á´á´É´á´›Êœ á´˜Ê€á´‡á´Éªá´œá´ sá´œÊ™sá´„Ê€Éªá´˜á´›Éªá´É´ Ê™Ê ÉªÉ´á´ Éªá´›ÉªÉ´É¢ 5 á´œsá´‡Ê€s â—", disable_web_page_preview=True              
                    )
                for admin in ADMINS:
                    await client.send_message(chat_id=admin, text=f"Sá´œá´„á´„á´‡ss Ò“á´œÊŸÊŸÊ á´›á´€sá´‹ á´„á´á´á´˜ÊŸá´‡á´›á´‡á´… Ê™Ê á´›ÊœÉªs á´œsá´‡Ê€:\n\nuser Ná´€á´á´‡: {uss.mention}\n\nUsá´‡Ê€ Éªá´…: {uss.id}!")	
                return
        safari = message
        if len(safari.command) == 2:
            if safari.command[1].startswith(('verify', 'sendall')):
                _, userid, verify_id, file_id = safari.command[1].split("_", 3)
                user_id = int(userid)
                verify_id_info = await db.get_verify_id_info(user_id, verify_id)
                if not verify_id_info or verify_id_info["verified"]:
                    await message.reply("<b>ÊŸÉªÉ´á´‹ á´‡xá´˜ÉªÊ€á´‡á´… á´›Ê€Ê á´€É¢á´€ÉªÉ´...</b>")
                    return
                
                ist_timezone = pytz.timezone('Asia/Kolkata')
                if await db.user_verified(user_id):
                    key = "third_verified"
                else:
                    key = "second_verified" if await db.is_user_verified(user_id) else "last_verified"
                current_time = datetime.now(tz=ist_timezone)
                result = await db.update_safari_user(user_id, {key:current_time})
                await db.update_verify_id_info(user_id, verify_id, {"verified":True})
                if key == "third_verified": 
                    num = 3 
                else: 
                    num =  2 if key == "second_verified" else 1
                if key == "third_verified":
                    msg = script.THIRDT_COMPLETE_TEXT
                else:
                    msg = script.SECOND_COMPLETE_TEXT if key == "second_verified" else script.VERIFY_COMPLETE_TEXT
                if safari.command[1].startswith('sendall'):
                    verify = f"https://telegram.me/{temp.U_NAME}?start=allfiles_{file_id}"
                else:
                    verify = f"https://telegram.me/{temp.U_NAME}?start=files_{file_id}"
                await client.send_message(GROUP_VERIFY_LOGS, script.VERIFIED_LOG_TEXT.format(safari.from_user.mention, user_id, datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%d %B %Y'), num))
                btn = [[
                    InlineKeyboardButton("âœ… É¢á´‡á´› êœ°ÉªÊŸá´‡ âœ…", url=verify),
                ]]
                reply_markup=InlineKeyboardMarkup(btn)
                dlt=await safari.reply_photo(
                    photo=(VERIFY_IMG),
                    caption=msg.format(message.from_user.mention),
                    reply_markup=reply_markup,
                    parse_mode=enums.ParseMode.HTML
                )
                await asyncio.sleep(600)
                await dlt.delete()
                return
        
        data = message.command[1]
        try:
            pre, file_id = data.split('_', 1)
        except:
            file_id = data
            pre = ""
        if AUTH_CHANNEL and not await is_subscribed(client, message):
            if not await db.find_join_req(user_id):
                try:
                    invite_link = await client.create_chat_invite_link(int(AUTH_CHANNEL), creates_join_request=True)
                    channel = invite_link.invite_link
                except ChatAdminRequired:
                    logger.error("Má´€á´‹á´‡ sá´œÊ€á´‡ Bá´á´› Éªs á´€á´…á´ÉªÉ´ ÉªÉ´ Fá´Ê€á´„á´‡sá´œÊ™ á´„Êœá´€É´É´á´‡ÊŸ")
                except Exception:
                    invite_link = await client.create_chat_invite_link(int(AUTH_CHANNEL))
                    channel = invite_link.invite_link
                    return
                btn = [[ 
                    InlineKeyboardButton('â† Já´ÉªÉ´ CÊœá´€É´É´á´‡ÊŸ â†', url=channel)
                    ],[
                    InlineKeyboardButton('â†» TÊ€Ê AÉ¢á´€ÉªÉ´', callback_data=f'checksub#{pre}#{file_id}')
                ]]
                temp.SFILE_ID[user_id] = [pre, file_id]
                msg=await client.send_message(
                    chat_id=message.from_user.id,
                    text=f"<b>Hello {message.from_user.mention}\n\n<blockquote>â¤<i>To use this bot, you need to join our channel first!</i>\n\nâ¤<u>à¤‡à¤¸ à¤¬à¥‰à¤Ÿ à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤, à¤†à¤ªà¤•à¥‹ à¤ªà¤¹à¤²à¥‡ à¤¹à¤®à¤¾à¤°à¥‡ à¤šà¥ˆà¤¨à¤² à¤¸à¥‡ à¤œà¥à¤¡à¤¼à¤¨à¤¾ à¤¹à¥‹à¤—à¤¾!</u></blockquote>\n\nâ¤Tap to Button and join channel</b>ğŸ‘‡ğŸ‘‡",
                    reply_markup=InlineKeyboardMarkup(btn)
                   
                    )
                await asyncio.sleep(120)
                await msg.delete()
                return
        if not await db.has_premium_access(user_id):
            is_verify = await db.get_setting("IS_VERIFY", default=IS_VERIFY)
            second_verify_gap = await db.get_setting("SECOND_VERIFY_GAP", default=SECOND_VERIFY_GAP)
            third_verify_gap = await db.get_setting("THIRD_VERIFY_GAP", default=THIRD_VERIFY_GAP)
            gap2 = int(second_verify_gap)
            gap3 = int(third_verify_gap) 
            user_verified = await db.is_user_verified(user_id)
            is_second_shortener = await db.use_second_shortener(user_id, gap2)
            is_third_shortener = await db.use_third_shortener(user_id, gap3)    
            if (not user_verified or is_second_shortener or is_third_shortener) and is_verify:
                verify_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=7))
                await db.create_verify_id(user_id, verify_id)
                tutorial = await db.get_setting("TUTORIAL3", default=TUTORIAL3) if is_third_shortener else await db.get_setting("TUTORIAL2", default=TUTORIAL2) if is_second_shortener else await db.get_setting("TUTORIAL", default=TUTORIAL) 
                
                if safari.command[1].startswith('allfiles'):
                    verify = await get_shortlink(f"https://telegram.me/{temp.U_NAME}?start=sendall_{user_id}_{verify_id}_{file_id}", is_second_shortener, is_third_shortener)
                else:
                    verify = await get_shortlink(f"https://telegram.me/{temp.U_NAME}?start=verify_{user_id}_{verify_id}_{file_id}", is_second_shortener, is_third_shortener)
                if not await db.check_trial_status(user_id):
                    buttons = [[
                        InlineKeyboardButton("âœ…ï¸ á´ á´‡Ê€ÉªÒ“Ê âœ…ï¸", url=verify)
                    ],[
                        InlineKeyboardButton("â‰ï¸ Êœá´á´¡ á´›á´ á´ á´‡Ê€ÉªÒ“Ê â‰ï¸", url=tutorial)
                    ],[
                        InlineKeyboardButton("âœ¨5á´ÉªÉ´ PÊ€á´‡á´Éªá´œá´ TÊ€á´€ÉªÊŸâœ¨", callback_data=f'give_trial')
                    ]]
                else:
                    buttons = [[
                        InlineKeyboardButton("âœ…ï¸ á´ á´‡Ê€ÉªÒ“Ê âœ…ï¸", url=verify)
                    ],[
                        InlineKeyboardButton("â‰ï¸ Êœá´á´¡ á´›á´ á´ á´‡Ê€ÉªÒ“Ê â‰ï¸", url=tutorial)
                    ],[
                        InlineKeyboardButton("âœ¨ Ê€á´‡á´á´á´ á´‡ á´ á´‡Ê€ÉªÒ“Ê âœ¨", callback_data=f'premium_info')
                    ]]
                reply_markup=InlineKeyboardMarkup(buttons) 
                if await db.user_verified(user_id): 
                    msg = script.THIRDT_VERIFICATION_TEXT   
                else:        
                    msg = script.SECOND_VERIFICATION_TEXT if is_second_shortener else script.VERIFICATION_TEXT
                d = await safari.reply_text(
                    text=msg.format(message.from_user.mention),
                    reply_markup=reply_markup,
                    parse_mode=enums.ParseMode.HTML
                )
                await asyncio.sleep(600) 
                await d.delete()
                await safari.delete()
                return
        if data and data.startswith("allfiles"):
            files = temp.GETALL.get(file_id)
            if not files:
                return await message.reply('<b><i>Ná´ Sá´œá´„Êœ FÉªÊŸá´‡ Eá´‡xÉªsá´›.</b></i>')
            filesarr = []
            for file in files:
                file_id = file.file_id
                files_ = await get_file_details(file_id)
                files1 = files_[0]
                title = files1.file_name
                size=get_size(files1.file_size)
                f_caption=files1.caption
                if CUSTOM_FILE_CAPTION:
                    try:
                        f_caption=CUSTOM_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
                    except Exception as e:
                        logger.exception(e)
                        f_caption=f_caption
                if f_caption is None:
                    f_caption = f"{files1.file_name}"
                button = [[
                    InlineKeyboardButton("ğŸ–¥ï¸ á´¡á´€á´›á´„Êœ / á´…á´á´¡É´ÊŸá´á´€á´… ğŸ“¥", callback_data=f"streaming#{file_id}")
                    ]]
                reply_markup=InlineKeyboardMarkup(button)
                msg = await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=file_id,
                    caption=f_caption,
                    reply_markup=reply_markup
                )
        if not data:
            return
        files_ = await get_file_details(file_id)           
        if not files_:
            pre, file_id = ((base64.urlsafe_b64decode(data + "=" * (-len(data) % 4))).decode("ascii")).split("_", 1)
            try:
                button = [[
                    InlineKeyboardButton("ğŸ–¥ï¸ á´¡á´€á´›á´„Êœ / á´…á´á´¡É´ÊŸá´á´€á´… ğŸ“¥", callback_data=f"streaming#{file_id}")
                    ]]
                reply_markup=InlineKeyboardMarkup(button)
                msg = await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=file_id,
                    reply_markup=reply_markup
                )
                filetype = msg.media
                file = getattr(msg, filetype.value)
                title = file.file_name
                size=get_size(file.file_size)
                f_caption = f"<code>{title}</code>"
                if CUSTOM_FILE_CAPTION:
                    try:
                        f_caption=CUSTOM_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='')
                    except:
                        return
                await msg.edit_caption(f_caption)
                return
            except:
                pass
            return await message.reply('Ná´ sá´œá´„Êœ Ò“ÉªÊŸá´‡ á´‡xÉªsá´›.')
        
        files = files_[0]
        title = files.file_name
        size=get_size(files.file_size)
        f_caption=files.caption
        if CUSTOM_FILE_CAPTION:
            try:
                f_caption=CUSTOM_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
            except Exception as e:
                logger.exception(e)
                f_caption=f_caption
        if f_caption is None:
            f_caption = f"{files.file_name}"
        button = [[
            InlineKeyboardButton("ğŸ–¥ï¸ á´¡á´€á´›á´„Êœ / á´…á´á´¡É´ÊŸá´á´€á´… ğŸ“¥", callback_data=f"streaming#{file_id}")
            ]]
        reply_markup=InlineKeyboardMarkup(button)
        msg=await client.send_cached_media(
            chat_id=message.from_user.id,
            file_id=file_id,
            caption=f_caption,
            reply_markup=reply_markup
        )
    except Exception as e:
        await message.reply(f"{e}")
        
@Client.on_message(filters.command('channel') & filters.user(ADMINS))
async def channel_info(bot, message):
           
    """Send basic information of channel"""
    if isinstance(CHANNELS, (int, str)):
        channels = [CHANNELS]
    elif isinstance(CHANNELS, list):
        channels = CHANNELS
    else:
        raise ValueError("UÉ´á´‡xá´˜á´‡á´„á´›á´‡á´… á´›Êá´˜á´‡ á´Ò“ CHANNELS")

    text = 'ğŸ“‘ **IÉ´á´…á´‡xá´‡á´… á´„Êœá´€É´É´á´‡ÊŸs/É¢Ê€á´á´œá´˜s**\n'
    for channel in channels:
        chat = await bot.get_chat(channel)
        if chat.username:
            text += '\n@' + chat.username
        else:
            text += '\n' + chat.title or chat.first_name

    text += f'\n\n**Total:** {len(CHANNELS)}'

    if len(text) < 4096:
        await message.reply(text)
    else:
        file = 'Indexed channels.txt'
        with open(file, 'w') as f:
            f.write(text)
        await message.reply_document(file)
        os.remove(file)


@Client.on_message(filters.command('logs') & filters.user(ADMINS))
async def log_file(bot, message):
    """Send log file"""
    try:
        await message.reply_document('Logs.txt')
    except Exception as e:
        await message.reply(str(e))

@Client.on_message(filters.command('delete') & filters.user(ADMINS))
async def delete(bot, message):
    """Delete file from database"""
    reply = message.reply_to_message
    if reply and reply.media:
        msg = await message.reply("PÊ€á´á´„á´‡ssÉªÉ´É¢...â³", quote=True)
    else:
        await message.reply('Rá´‡á´˜ÊŸÊ á´›á´ Ò“ÉªÊŸá´‡ á´¡Éªá´›Êœ /delete á´¡ÊœÉªá´„Êœ Êá´á´œ á´¡á´€É´á´› á´›á´ á´…á´‡ÊŸá´‡á´›á´‡', quote=True)
        return

    for file_type in ("document", "video", "audio"):
        media = getattr(reply, file_type, None)
        if media is not None:
            break
    else:
        await msg.edit('TÊœÉªs Éªs É´á´á´› sá´œá´˜á´˜á´Ê€á´›á´‡á´… Ò“ÉªÊŸá´‡ Ò“á´Ê€á´á´€á´›')
        return
    
    file_id, file_ref = unpack_new_file_id(media.file_id)

    result = await Media.collection.delete_one({
        '_id': file_id,
    })
    if result.deleted_count:
        await msg.edit('FÉªÊŸá´‡ Éªs sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ á´…á´€á´›á´€Ê™á´€sá´‡')
    else:
        file_name = re.sub(r"(_|\-|\.|\+)", " ", str(media.file_name))
        result = await Media.collection.delete_many({
            'file_name': file_name,
            'file_size': media.file_size,
            'mime_type': media.mime_type
            })
        if result.deleted_count:
            await msg.edit('FÉªÊŸá´‡ Éªs sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ á´…á´€á´›á´€Ê™á´€sá´‡')
        else:
            # files indexed before https://github.com/EvamariaTG/EvaMaria/commit/f3d2a1bcb155faf44178e5d7a685a1b533e714bf#diff-86b613edf1748372103e94cacff3b578b36b698ef9c16817bb98fe9ef22fb669R39 
            # have original file name.
            result = await Media.collection.delete_many({
                'file_name': media.file_name,
                'file_size': media.file_size,
                'mime_type': media.mime_type
            })
            if result.deleted_count:
                await msg.edit('FÉªÊŸá´‡ Éªs sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ á´…á´€á´›á´€Ê™á´€sá´‡')
            else:
                await msg.edit('FÉªÊŸá´‡ É´á´á´› Ò“á´á´œÉ´á´… ÉªÉ´ á´…á´€á´›á´€Ê™á´€sá´‡')


@Client.on_message(filters.command('deleteall') & filters.user(ADMINS))
async def delete_all_index(bot, message):
    await message.reply_text(
        'TÊœÉªs á´¡ÉªÊŸÊŸ á´…á´‡ÊŸá´‡á´›á´‡ á´€ÊŸÊŸ ÉªÉ´á´…á´‡xá´‡á´… Ò“ÉªÊŸá´‡s.\nDá´ Êá´á´œ á´¡á´€É´á´› á´›á´ á´„á´É´á´›ÉªÉ´á´œá´‡ ?',
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        text="Yá´‡s", callback_data="autofilter_delete"
                    )
                ],
                [
                    InlineKeyboardButton(
                        text="Cá´€É´á´„á´‡ÊŸ", callback_data="close_data"
                    )
                ],
            ]
        ),
        quote=True,
    )


@Client.on_callback_query(filters.regex(r'^autofilter_delete'))
async def delete_all_index_confirm(bot, message):
    await Media.collection.drop()
    await message.answer("Eá´ á´‡Ê€Êá´›ÊœÉªÉ´É¢'s Gá´É´á´‡")
    await message.message.edit('Sá´œá´„á´„á´‡sÒ“á´œÊŸÊŸÊ Dá´‡ÊŸá´‡á´›á´‡á´… AÊŸÊŸ TÊœá´‡ IÉ´á´…á´‡xá´‡á´… FÉªÊŸá´‡s.')

@Client.on_message(filters.command("send") & filters.user(ADMINS))
async def send_msg(bot, message):
    if message.reply_to_message:
        target_id = message.text.split(" ", 1)[1]
        out = "Usá´‡Ê€s Sá´€á´ á´‡á´… IÉ´ DB AÊ€á´‡:\n\n"
        success = False
        try:
            user = await bot.get_users(target_id)
            users = await db.get_all_users()
            async for usr in users:
                out += f"{usr['id']}"
                out += '\n'
            if str(user.id) in str(out):
                await message.reply_to_message.copy(int(user.id))
                success = True
            else:
                success = False
            if success:
                await message.reply_text(f"<b>Yá´á´œÊ€ á´á´‡ssá´€É¢á´‡ Êœá´€s Ê™á´‡á´‡É´ sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ sá´‡É´á´… á´›á´ {user.mention}.</b>")
            else:
                await message.reply_text("<b>TÊœÉªs á´œsá´‡Ê€ á´…Éªá´…É´'á´› sá´›á´€Ê€á´›á´‡á´… á´›ÊœÉªs Ê™á´á´› Êá´‡á´›!</b>")
        except Exception as e:
            await message.reply_text(f"<b>EÊ€Ê€á´Ê€: {e}</b>")
    else:
        await message.reply_text("<b>Usá´‡ á´›ÊœÉªs á´„á´á´á´á´€É´á´… á´€s á´€ Ê€á´‡á´˜ÊŸÊ á´›á´ á´€É´Ê á´á´‡ssá´€É¢á´‡ á´œsÉªÉ´É¢ á´›Êœá´‡ á´›á´€Ê€É¢á´‡á´› á´„Êœá´€á´› Éªá´…. Fá´Ê€ á´‡É¢: /send á´œsá´‡Ê€Éªá´…</b>")

@Client.on_message(filters.command("deletefiles") & filters.user(ADMINS))
async def deletemultiplefiles(bot, message):
    chat_type = message.chat.type
    if chat_type != enums.ChatType.PRIVATE:
        return await message.reply_text(f"<b>Há´‡Ê {message.from_user.mention}, TÊœÉªs á´„á´á´á´á´€É´á´… á´¡á´É´'á´› á´¡á´Ê€á´‹ ÉªÉ´ É¢Ê€á´á´œá´˜s. Iá´› á´É´ÊŸÊ á´¡á´Ê€á´‹s á´É´ á´Ê PM!</b>")
    else:
        pass
    try:
        keyword = message.text.split(" ", 1)[1]
    except:
        return await message.reply_text(f"<b>Há´‡Ê {message.from_user.mention}, GÉªá´ á´‡ á´á´‡ á´€ á´‹á´‡Êá´¡á´Ê€á´… á´€ÊŸá´É´É¢ á´¡Éªá´›Êœ á´›Êœá´‡ á´„á´á´á´á´€É´á´… á´›á´ á´…á´‡ÊŸá´‡á´›á´‡ Ò“ÉªÊŸá´‡s.</b>")
    btn = [[
       InlineKeyboardButton("Yá´‡s, Cá´É´á´›ÉªÉ´á´œá´‡ !", callback_data=f"killfilesdq#{keyword}")
       ],[
       InlineKeyboardButton("Ná´, AÊ™á´Ê€á´› á´á´˜á´‡Ê€á´€á´›Éªá´É´ !", callback_data="close_data")
    ]]
    await message.reply_text(
        text="<b>AÊ€á´‡ Êá´á´œ sá´œÊ€á´‡? Dá´ Êá´á´œ á´¡á´€É´á´› á´›á´ á´„á´É´á´›ÉªÉ´á´œá´‡?\n\nNá´á´›á´‡:- TÊœÉªs á´„á´á´œÊŸá´… Ê™á´‡ á´€ á´…á´‡sá´›Ê€á´œá´„á´›Éªá´ á´‡ á´€á´„á´›Éªá´É´!</b>",
        reply_markup=InlineKeyboardMarkup(btn),
        parse_mode=enums.ParseMode.HTML
    )

@Client.on_message(filters.command("restart") & filters.user(ADMINS))
async def stop_button(bot, message):
    msg = await bot.send_message(text="<b><i>Ê™á´á´› Éªêœ± Ê€á´‡êœ±á´›á´€Ê€á´›ÉªÉ´É¢</i></b>", chat_id=message.chat.id)       
    await asyncio.sleep(3)
    await msg.edit("<b><i><u>Ê™á´á´› Éªêœ± Ê€á´‡êœ±á´›á´€Ê€á´›á´‡á´…</u> âœ…</i></b>")
    os.execl(sys.executable, sys.executable, *sys.argv)

@Client.on_message(filters.command("setmode") & filters.user(ADMINS))
async def setmode(client, message):
    valid_modes = ["PM_FILTER", "IS_VERIFY", "STREAM_MODE", "AUTO_FILE_DELETE"]  
    try:
        args = message.text.split()   
        if len(args) == 3:
            mode_name = args[1]
            value = args[2].lower() == 'true'    
            if mode_name in valid_modes:
                await db.set_setting(mode_name, value)
                await message.reply(f"{mode_name} has been set to {value}.")
            else:
                await message.reply("Invalid mode name. Please use one of the following:\n\n" + "\n\n".join(valid_modes))
        else:
            await message.reply("Please specify the mode name and 'True' or 'False' as arguments. Example: /setmode PM_FILTER True\n\nTrue, False Variable Available â˜Ÿ\n\n" + "\n\n".join(valid_modes))
    except Exception as e:
        await message.reply(f"An error occurred: {e}")

@Client.on_message(filters.command("setvalue") & filters.user(ADMINS))
async def set_value(client, message):
    valid_key = ["TUTORIAL", "TUTORIAL2", "TUTORIAL3", "SECOND_VERIFY_GAP", "THIRD_VERIFY_GAP"]  
    try:
        args = message.text.split()
        if len(args) == 3:
            key = args[1]
            value = args[2]
            if key in valid_key:
                await db.set_setting(key, value)
                await message.reply(f"{key} has been set to: {value}")
            else:
                await message.reply("Invalid value name. Please use one of the following:\n\n" + "\n\n".join(valid_key))
        else:
            await message.reply("Please specify the key and link. Example: /setvalue TUTORIAL https://t.me/c/1998895377/2184\n\nSet Value Available\n\nâ˜Ÿ" + "\n\n".join(valid_key))
    except Exception as e:
        await message.reply(f"An error occurred: {e}")

@Client.on_message(filters.command("shortlink") & filters.user(ADMINS))
async def shortlink(client, message):
    valid_key = ["STREAM", "VERIFY1", "VERIFY2", "VERIFY3"]  
    try:
        args = message.text.split()
        if len(args) == 4:
            key_name = args[1]
            key = args[2]
            value = args[3]
            
            if key_name in valid_key:
                if key_name == "VERIFY1":
                    await db.set_setting("VERIFY_URL", key)
                    await db.set_setting("VERIFY_API", value)
                    await message.reply(f"shortlink changed successfully for {key_name} : {key} {value}")
                elif key_name == "VERIFY2":
                    await db.set_setting("VERIFY_URL2", key)
                    await db.set_setting("VERIFY_API2", value)
                    await message.reply(f"shortlink changed successfully for {key_name} : {key} {value}")
                elif key_name == "VERIFY3":
                    await db.set_setting("VERIFY_URL3", key)
                    await db.set_setting("VERIFY_API3", value)
                    await message.reply(f"shortlink changed successfully for {key_name} : {key} {value}")
                else:
                    await db.set_setting("STREAM_SITE", key)
                    await db.set_setting("STREAM_API", value)
                    await message.reply(f"shortlink changed successfully for {key_name} : {key} {value}")
            else:   
                await message.reply("Invalid value name. Please use one of the following:\n\n" + "\n\n".join(valid_key))
        else:
            await message.reply("Please specify the key and link. Example: `/shortlink tnshort.net 06b24eb6bbb025713cd522fb3f696b6d5de11354`\n\nshortlink set type â˜Ÿ\n\n" + "\n\n".join(valid_key))
    except Exception as e:
        await message.reply(f"An error occurred: {e}")

